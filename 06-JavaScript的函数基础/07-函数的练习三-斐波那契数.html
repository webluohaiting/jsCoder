<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 需求：求一个菲波那切数列(下一个数为前两个数之和)
    // 1 1 2 3 5 8 13 21 34.....

    // 自己实现
    // function fib(n) {
    //   var arr = [1, 1]
    //   for (var i = 2; i < n + 1; i++) {
    //     arr[i] = arr[i-2] + arr[i-1]
    //   }
    //   console.log(arr);
    //   return arr[n]
    // }
    // console.log(fib(8));

    // 1.普通方式
    function fib(n) {
      if (n === 0 | n === 1) return 1

      var num1 = 1
      var num2 = 1
      var sum = 2
      for (var i = 2; i < n; i++) {
        num1 = num2
        num2 = sum
        sum = num1 + num2
      }
      return sum
    }
    console.log(fib(0));
    console.log(fib(1));
    console.log(fib(2));
    console.log(fib(3));
    console.log(fib(4));
    console.log(fib(5));
    console.log(fib(6));

    // 2.递归调用:
    // 开发中尽量避免使用递归：
    // 1.递归如果没有写好结束条件，意味着会无限调用
    // 2.递归调用非常占据栈空间内存（空间复杂度）/效率比较低（时间复杂度）

    // 什么是递归调用
    // 2.1 一个函数可以去调用另一个函数
    function test1() {
      console.log('test1');
      test2()
    }
    
    function test2() {
      console.log('test2');
    }

    test1()

    // 2.2 函数自己调用自己:递归调用
    // function test() {
    //   console.log('test被调用');
    //   test()
    // }

    // test()

    // 2.3 使用递归调用实现菲波那切数列
    function fib2(n) {
      if (n === 0 | n === 1) return 1
      return fib2(n-1) + fib2(n-2)
    }
    console.log(fib2(0));
    console.log(fib2(1));
    console.log(fib2(2));
    console.log(fib2(3));
    console.log(fib2(4));
    console.log(fib2(5));
    console.log(fib2(6));
  </script>
</body>
</html>